name: Build and Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build:
    name: Build (${{ matrix.name }})
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: windows-amd64
            runner: windows-latest
            setup_python: true
            python_cmd: python
            exe_name: integrated_script.exe
            out_name: integrated_script-${{ github.ref_name }}-windows-amd64.exe
          - name: linux-amd64
            runner: ubuntu-latest
            setup_python: true
            python_cmd: python
            exe_name: integrated_script
            out_name: integrated_script-${{ github.ref_name }}-linux-amd64
          - name: linux-arm64
            runner:
              - self-hosted
              - Linux
              - ARM64
            setup_python: false
            python_cmd: /home/luohao/.pyenv/versions/3.11.9/bin/python
            exe_name: integrated_script
            out_name: integrated_script-${{ github.ref_name }}-linux-arm64

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - uses: actions/setup-python@v5
      if: ${{ matrix.setup_python == true }}
      with:
        python-version: '3.11'

    - name: Detect Python version (self-hosted)
      if: ${{ matrix.setup_python == false }}
      shell: bash
      run: |
        ${{ matrix.python_cmd }} -c "import sys; print(f'PYTHON_VERSION={sys.version_info.major}.{sys.version_info.minor}')" >> "$GITHUB_ENV"

    - name: Cache pip (self-hosted)
      if: ${{ matrix.setup_python == false }}
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/pip
        key: ${{ runner.os }}-${{ runner.arch }}-py${{ env.PYTHON_VERSION }}-pip-${{ hashFiles('requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-${{ runner.arch }}-py${{ env.PYTHON_VERSION }}-pip-

    - name: Cache venv (self-hosted)
      if: ${{ matrix.setup_python == false }}
      uses: actions/cache@v4
      with:
        path: .venv
        key: ${{ runner.os }}-${{ runner.arch }}-py${{ env.PYTHON_VERSION }}-venv-${{ hashFiles('requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-${{ runner.arch }}-py${{ env.PYTHON_VERSION }}-venv-

    - name: Prepare Python runtime
      shell: bash
      run: |
        if [[ "${{ matrix.setup_python }}" == "true" ]]; then
          echo "PYTHON_CMD=${{ matrix.python_cmd }}" >> "$GITHUB_ENV"
        else
          if [[ ! -x ".venv/bin/python" ]]; then
            ${{ matrix.python_cmd }} -m venv .venv
          fi
          echo "PYTHON_CMD=$PWD/.venv/bin/python" >> "$GITHUB_ENV"
        fi

    - name: Install dependencies
      shell: bash
      run: |
        PYTHONPATH= PYTHONNOUSERSITE=1 $PYTHON_CMD -m pip install --upgrade pip
        PYTHONPATH= PYTHONNOUSERSITE=1 $PYTHON_CMD -m pip install -r requirements.txt pyinstaller

    - name: Verify Python runtime
      shell: bash
      run: |
        PYTHONPATH= PYTHONNOUSERSITE=1 $PYTHON_CMD --version

    - name: Build executable
      shell: bash
      run: PYTHONPATH= PYTHONNOUSERSITE=1 $PYTHON_CMD build_exe.py

    - name: Rename executable with release tag
      env:
        EXE_NAME: ${{ matrix.exe_name }}
        OUT_NAME: ${{ matrix.out_name }}
      shell: bash
      run: |
        python - <<'PY'
        import os
        from pathlib import Path

        exe_name = os.environ.get("EXE_NAME")
        out_name = os.environ.get("OUT_NAME")
        exe = Path("dist") / exe_name
        if exe.exists() and out_name:
            exe.rename(exe.with_name(out_name))
        PY

    - name: Upload build artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.name }}
        path: dist/${{ matrix.out_name }}

  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: build

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        path: dist

    - name: Generate release notes
      env:
        TAG: ${{ github.ref_name }}
        REPO: ${{ github.repository }}
      shell: bash
      run: |
        python - <<'PY'
        import os
        import re
        import subprocess
        from datetime import datetime, timedelta

        tag = os.environ.get("TAG", "").strip()
        repo = os.environ.get("REPO", "").strip()

        def run(*args: str) -> str:
          return subprocess.check_output(
            list(args),
            text=True,
            encoding="utf-8",
            errors="replace",
          ).strip()

        prev = None
        if tag:
          tags = run(
            "git",
            "for-each-ref",
            "--sort=version:refname",
            "--format=%(refname:short)",
            "refs/tags/v[0-9]*.[0-9]*.[0-9]*",
          ).splitlines()
          try:
            idx = tags.index(tag)
          except ValueError:
            idx = -1
          if idx > 0:
            prev = tags[idx - 1]

        rev_range = f"{prev}..{tag}" if prev else tag
        raw = run(
          "git",
          "log",
          "--no-merges",
          "--pretty=format:%s|%h",
          rev_range,
        )
        lines = [ln for ln in raw.splitlines() if ln.strip()]

        categories = {
          "新增": [],
          "修复": [],
          "文档": [],
          "CI/构建": [],
          "重构": [],
          "测试": [],
          "其他": [],
        }

        type_re = re.compile(r"^(?P<type>\\w+)(?:\\((?P<scope>[^)]+)\\))?:\\s*(?P<msg>.+)$")

        for ln in lines:
          subject, sha = ln.rsplit("|", 1)
          subject = subject.strip()
          sha = sha.strip()
          lower = subject.lower()
          m = type_re.match(subject)
          if m:
            msg = m.group("msg").strip()
            scope = (m.group("scope") or "").strip()
            display = f"{msg} ({scope})" if scope else msg
            t = m.group("type").lower()
          else:
            display = subject
            t = lower.split(":", 1)[0]

          if t.startswith("feat"):
            categories["新增"].append((display, sha))
          elif t.startswith("fix"):
            categories["修复"].append((display, sha))
          elif t.startswith("docs"):
            categories["文档"].append((display, sha))
          elif t.startswith("ci"):
            categories["CI/构建"].append((display, sha))
          elif t.startswith("refactor"):
            categories["重构"].append((display, sha))
          elif t.startswith("test"):
            categories["测试"].append((display, sha))
          else:
            categories["其他"].append((display, sha))

        def format_section(title: str, items: list[tuple[str, str]]) -> str:
          if not items:
            return ""
          lines = [f"## {title}", ""]
          for subject, sha in items:
            lines.append(f"- {subject} ({sha})")
          lines.append("")
          return "\n".join(lines)

        body = []
        body.append(f"# {tag}")
        body.append("")
        if prev:
          body.append(f"对比范围：{prev} → {tag}")
          if repo:
            body.append(
              f"完整对比：https://github.com/{repo}/compare/{prev}...{tag}"
            )
        else:
          body.append("对比范围：初始发布")
        body.append("")
        for section in ("新增", "修复", "文档", "CI/构建", "重构", "测试", "其他"):
          part = format_section(section, categories[section])
          if part:
            body.append(part)
        if not any(categories.values()):
          body.append("本次没有可展示的提交记录。")
          body.append("")
        utc8 = datetime.utcnow().replace(microsecond=0) + timedelta(hours=8)
        body.append(f"生成时间：{utc8.strftime('%Y-%m-%d %H:%M')} 北京时间")
        body.append("")

        with open("release_body.md", "w", encoding="utf-8") as f:
          f.write("\n".join(body))
        PY

    - name: Create Release
      uses: softprops/action-gh-release@v2
      with:
        files: |
          dist/windows-amd64/integrated_script-${{ github.ref_name }}-windows-amd64.exe
          dist/linux-amd64/integrated_script-${{ github.ref_name }}-linux-amd64
          dist/linux-arm64/integrated_script-${{ github.ref_name }}-linux-arm64
        body_path: release_body.md
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
